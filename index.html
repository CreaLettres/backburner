<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="Backburner : Simple and reliable beanstalkd job queue for ruby" />

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Backburner</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/nesquena/backburner">View on GitHub</a>

          <h1 id="project_title">Backburner</h1>
          <h2 id="project_tagline">Simple and reliable beanstalkd job queue for ruby</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/nesquena/backburner/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/nesquena/backburner/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h1>Backburner</h1>

<p>Backburner is a <a href="http://kr.github.com/beanstalkd/">beanstalkd</a>-powered job queue that can handle a very high volume of jobs.
You create background jobs and place them on multiple work queues to be processed later.</p>

<p>Processing background jobs reliably has never been easier than with beanstalkd and Backburner. This gem works with any ruby-based
web framework, but is especially suited for use with <a href="http://sinatrarb.com">Sinatra</a>, <a href="http://padrinorb.com">Padrino</a> and Rails.</p>

<p>If you want to use beanstalk for your job processing, consider using Backburner.
Backburner is heavily inspired by Resque and DelayedJob. Backburner stores all jobs as simple JSON message payloads.
Persistent queues are supported when beanstalkd persistence mode is enabled.</p>

<p>Backburner supports multiple queues, job priorities, delays, and timeouts. In addition, 
Backburner has robust support for retrying failed jobs, handling error cases,
custom logging, and extensible plugin hooks.</p>

<h2>Why Backburner?</h2>

<p>Backburner is well tested and has a familiar, no-nonsense approach to job processing, but that is of secondary importance.
Let's face it, there are a lot of options for background job processing. <a href="https://github.com/collectiveidea/delayed_job">DelayedJob</a>,
and <a href="https://github.com/defunkt/resque">Resque</a> are the first that come to mind immediately. So, how do we make sense
of which one to use? And why use Backburner over other alternatives?</p>

<p>The key to understanding the differences lies in understanding the different projects and protocols that power these popular queue
libraries under the hood. Every job queue requires a queue store that jobs are put into and pulled out of.
In the case of Resque, jobs are processed through <strong>Redis</strong>, a persistent key-value store. In the case of DelayedJob, jobs are processed through
<strong>ActiveRecord</strong> and a database such as PostgreSQL.</p>

<p>The work queue underlying these gems tells you infinitely more about the differences than anything else.
Beanstalk is probably the best solution for job queues available today for many reasons.
The real question then is... "Why Beanstalk?".</p>

<h2>Why Beanstalk?</h2>

<p>Illya has an excellent blog post
<a href="http://www.igvita.com/2010/05/20/scalable-work-queues-with-beanstalk/">Scalable Work Queues with Beanstalk</a> and
Adam Wiggins posted <a href="http://adam.heroku.com/past/2010/4/24/beanstalk_a_simple_and_fast_queueing_backend/">an excellent comparison</a>.</p>

<p>You will quickly see that <strong>beanstalkd</strong> is an underrated but incredible project that is extremely well-suited as a job queue.
Significantly better suited for this task than Redis or a database. Beanstalk is a simple,
and a very fast work queue service rolled into a single binary - it is the memcached of work queues.
Originally built to power the backend for the 'Causes' Facebook app, it is a mature and production ready open source project.
<a href="http://www.postrank.com">PostRank</a> uses beanstalk to reliably process millions of jobs a day.</p>

<p>A single instance of Beanstalk is perfectly capable of handling thousands of jobs a second (or more, depending on your job size)
because it is an in-memory, event-driven system. Powered by libevent under the hood,
it requires zero setup (launch and forget, à la memcached), optional log based persistence, an easily parsed ASCII protocol,
and a rich set of tools for job management that go well beyond a simple FIFO work queue.</p>

<p>Beanstalkd supports the following features out of the box:</p>

<table>
<tr>
<th>Feature</th>
<th>Description</th>
</tr>
<tr>
<td><strong>Parallelized</strong></td>
<td>Supports multiple work queues created on demand.</td>
</tr>
<tr>
<td><strong>Reliable</strong></td>
<td>Beanstalk’s reserve, work, delete cycle ensures reliable processing.</td>
</tr>
<tr>
<td><strong>Scheduling</strong></td>
<td>Delay enqueuing jobs by a specified interval to schedule processing later</td>
</tr>
<tr>
<td><strong>Fast</strong></td>
<td>Processes thousands of jobs per second without breaking a sweat.</td>
</tr>
<tr>
<td><strong>Priorities</strong></td>
<td>Specify priority so important jobs can be processed quickly.</td>
</tr>
<tr>
<td><strong>Persistence</strong></td>
<td>Jobs are stored in memory for speed, but logged to disk for safe keeping.</td>
</tr>
<tr>
<td><strong>Federation</strong></td>
<td>Horizontal scalability provided through federation by the client.</td>
</tr>
<tr>
<td><strong>Error Handling</strong></td>
<td>Bury any job which causes an error for later debugging and inspection.</td>
</tr>
</table><p>Keep in mind that these features are supported out of the box with beanstalk and require no special code within this gem to support.
In the end, <strong>beanstalk is the ideal job queue</strong> while also being ridiculously easy to install and setup.</p>

<h2>Installation</h2>

<p>First, you probably want to <a href="http://kr.github.com/beanstalkd/download.html">install beanstalkd</a>, which powers the job queues.
Depending on your platform, this should be as simple as (for Ubuntu):</p>

<pre><code>$ sudo apt-get install beanstalkd
</code></pre>

<p>Add this line to your application's Gemfile:</p>

<pre><code>gem 'backburner'
</code></pre>

<p>And then execute:</p>

<pre><code>$ bundle
</code></pre>

<p>Or install it yourself as:</p>

<pre><code>$ gem install backburner
</code></pre>

<h2>Configuration</h2>

<p>Backburner is extremely simple to setup. Just configure basic settings for backburner:</p>

<div class="highlight"><pre><span class="no">Backburner</span><span class="o">.</span><span class="n">configure</span> <span class="k">do</span> <span class="o">|</span><span class="n">config</span><span class="o">|</span>
  <span class="n">config</span><span class="o">.</span><span class="n">beanstalk_url</span>    <span class="o">=</span> <span class="o">[</span><span class="s2">"beanstalk://127.0.0.1"</span><span class="p">,</span> <span class="s2">"..."</span><span class="o">]</span>
  <span class="n">config</span><span class="o">.</span><span class="n">tube_namespace</span>   <span class="o">=</span> <span class="s2">"some.app.production"</span>
  <span class="n">config</span><span class="o">.</span><span class="n">on_error</span>         <span class="o">=</span> <span class="nb">lambda</span> <span class="p">{</span> <span class="o">|</span><span class="n">e</span><span class="o">|</span> <span class="nb">puts</span> <span class="n">e</span> <span class="p">}</span>
  <span class="n">config</span><span class="o">.</span><span class="n">max_job_retries</span>  <span class="o">=</span> <span class="mi">3</span> <span class="c1"># default 0 retries</span>
  <span class="n">config</span><span class="o">.</span><span class="n">retry_delay</span>      <span class="o">=</span> <span class="mi">2</span> <span class="c1"># default 5 seconds</span>
  <span class="n">config</span><span class="o">.</span><span class="n">default_priority</span> <span class="o">=</span> <span class="mi">65536</span>
  <span class="n">config</span><span class="o">.</span><span class="n">respond_timeout</span>  <span class="o">=</span> <span class="mi">120</span>
  <span class="n">config</span><span class="o">.</span><span class="n">default_worker</span>   <span class="o">=</span> <span class="no">Backburner</span><span class="o">::</span><span class="no">Workers</span><span class="o">::</span><span class="no">Simple</span>
  <span class="n">config</span><span class="o">.</span><span class="n">logger</span>           <span class="o">=</span> <span class="no">Logger</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="no">STDOUT</span><span class="p">)</span>
<span class="k">end</span>
</pre></div>

<p>The key options available are:</p>

<table>
<tr>
<th>Option</th>
<th>Description</th>
</tr>
<tr>
<td><code>beanstalk_url</code></td>
<td>Address such as 'beanstalk://127.0.0.1' or an array of addresses.</td>
</tr>
<tr>
<td><code>tube_namespace</code></td>
<td>Prefix used for all tubes related to this backburner queue.</td>
</tr>
<tr>
<td><code>on_error</code></td>
<td>Lambda invoked with the error whenever any job in the system fails.</td>
</tr>
<tr>
<td><code>default_worker</code></td>
<td>Worker class that will be used if no other worker is specified.</td>
</tr>
<tr>
<td><code>max_job_retries</code></td>
<td>Integer defines how many times to retry a job before burying.</td>
</tr>
<tr>
<td><code>retry_delay</code></td>
<td>Integer defines the base time to wait (in secs) between job retries.</td>
</tr>
<tr>
<td><code>logger</code></td>
<td>Logger recorded to when backburner wants to report info or errors.</td>
</tr>
</table><h2>Usage</h2>

<p>Backburner allows you to create jobs and place them on a beanstalk queue, and later pull those jobs off the queue and
process them asynchronously.</p>

<h3>Enqueuing Jobs</h3>

<p>At the core, Backburner is about jobs that can be processed. Jobs are simple ruby objects with a method defined named <code>perform</code>.</p>

<p>Any object which responds to <code>perform</code> can be queued as a job. Job objects are queued as JSON to be later processed by a task runner.
Here's an example:</p>

<div class="highlight"><pre><span class="k">class</span> <span class="nc">NewsletterJob</span>
  <span class="kp">include</span> <span class="no">Backburner</span><span class="o">::</span><span class="no">Queue</span>
  <span class="n">queue</span> <span class="s2">"newsletter"</span>  <span class="c1"># defaults to 'newsletter-job'</span>
  <span class="n">queue_priority</span> <span class="mi">1000</span> <span class="c1"># most urgent priority is 0</span>

  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">perform</span><span class="p">(</span><span class="n">email</span><span class="p">,</span> <span class="n">body</span><span class="p">)</span>
    <span class="no">NewsletterMailer</span><span class="o">.</span><span class="n">deliver_text_to_email</span><span class="p">(</span><span class="n">email</span><span class="p">,</span> <span class="n">body</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>

<p>Notice that you can include the optional <code>Backburner::Queue</code> module so you can specify a <code>queue</code> name for this job.
Jobs can be enqueued with:</p>

<div class="highlight"><pre><span class="no">Backburner</span><span class="o">.</span><span class="n">enqueue</span> <span class="no">NewsletterJob</span><span class="p">,</span> <span class="s1">'foo@admin.com'</span><span class="p">,</span> <span class="s1">'lorem ipsum...'</span>
</pre></div>

<p><code>Backburner.enqueue</code> accepts first a ruby object that supports <code>perform</code> and then a series of parameters
to that object's <code>perform</code> method. The queue name used by default is the normalized class name (i.e <code>{namespace}.newsletter-job</code>)
if not otherwise specified.</p>

<h3>Simple Async Jobs</h3>

<p>In addition to defining custom jobs, a job can also be enqueued by invoking the <code>async</code> method on any object which
includes <code>Backburner::Performable</code>. Async enqueuing works for both instance and class methods on any <em>performable</em> object.</p>

<div class="highlight"><pre><span class="k">class</span> <span class="nc">User</span>
  <span class="kp">include</span> <span class="no">Backburner</span><span class="o">::</span><span class="no">Performable</span>
  <span class="n">queue</span> <span class="s2">"user-jobs"</span>  <span class="c1"># defaults to 'user'</span>
  <span class="n">queue_priority</span> <span class="mi">500</span> <span class="c1"># most urgent priority is 0</span>

  <span class="k">def</span> <span class="nf">activate</span><span class="p">(</span><span class="n">device_id</span><span class="p">)</span>
    <span class="vi">@device</span> <span class="o">=</span> <span class="no">Device</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">device_id</span><span class="p">)</span>
    <span class="c1"># ...</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">reset_password</span><span class="p">(</span><span class="n">user_id</span><span class="p">)</span>
    <span class="c1"># ...</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="c1"># Async works for instance methods on a persisted model</span>
<span class="vi">@user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">first</span>
<span class="vi">@user</span><span class="o">.</span><span class="n">async</span><span class="p">(</span><span class="ss">:ttr</span> <span class="o">=&gt;</span> <span class="mi">100</span><span class="p">,</span> <span class="ss">:queue</span> <span class="o">=&gt;</span> <span class="s2">"activate"</span><span class="p">)</span><span class="o">.</span><span class="n">activate</span><span class="p">(</span><span class="vi">@device</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
<span class="c1"># ..as well as for class methods</span>
<span class="no">User</span><span class="o">.</span><span class="n">async</span><span class="p">(</span><span class="ss">:pri</span> <span class="o">=&gt;</span> <span class="mi">100</span><span class="p">,</span> <span class="ss">:delay</span> <span class="o">=&gt;</span> <span class="mi">10</span><span class="o">.</span><span class="n">seconds</span><span class="p">)</span><span class="o">.</span><span class="n">reset_password</span><span class="p">(</span><span class="vi">@user</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
</pre></div>

<p>This will automatically enqueue a job for that user record that will run <code>activate</code> with the specified argument.
Note that you can set the queue name and queue priority at the class level and
you are also able to pass <code>pri</code>, <code>ttr</code>, <code>delay</code> and <code>queue</code> directly as options into <code>async</code>.
The queue name used by default is the normalized class name (i.e <code>{namespace}.user</code>) if not otherwise specified.</p>

<h3>Working Jobs</h3>

<p>Backburner workers are processes that run forever handling jobs that get reserved. Starting a worker in ruby code is simple:</p>

<div class="highlight"><pre><span class="no">Backburner</span><span class="o">.</span><span class="n">work</span>
</pre></div>

<p>This will process jobs in all queues but you can also restrict processing to specific queues:</p>

<div class="highlight"><pre><span class="no">Backburner</span><span class="o">.</span><span class="n">work</span><span class="p">(</span><span class="s1">'newsletter_sender'</span><span class="p">)</span>
</pre></div>

<p>The Backburner worker also exists as a rake task:</p>

<div class="highlight"><pre><span class="nb">require</span> <span class="s1">'backburner/tasks'</span>
</pre></div>

<p>so you can run:</p>

<pre><code>$ QUEUES=newsletter-sender,push-message rake backburner:work
</code></pre>

<p>You can also run the backburner binary for a convenient worker:</p>

<pre><code>bundle exec backburner newsletter-sender,push-message -d -P /var/run/backburner.pid -l /var/log/backburner.log
</code></pre>

<p>This will daemonize the worker and store the pid and logs automatically.</p>

<h3>Persistence</h3>

<p>Jobs are persisted to queues as JSON objects. Let's take our <code>User</code>
example from above. We'll run the following code to create a job:</p>

<div class="highlight"><pre><span class="no">User</span><span class="o">.</span><span class="n">async</span><span class="o">.</span><span class="n">reset_password</span><span class="p">(</span><span class="vi">@user</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
</pre></div>

<p>The following JSON will be stored in the <code>{namespace}.user</code> queue:</p>

<div class="highlight"><pre><span class="p">{</span>
    <span class="s1">'class'</span><span class="o">:</span> <span class="s1">'User'</span><span class="p">,</span>
    <span class="s1">'args'</span><span class="o">:</span> <span class="p">[</span><span class="nx">nil</span><span class="p">,</span> <span class="s1">'reset_password'</span><span class="p">,</span> <span class="mi">123</span><span class="p">]</span>
<span class="p">}</span>
</pre></div>

<p>The first argument is the 'id' of the object in the case of an instance method being async'ed. For example:</p>

<div class="highlight"><pre><span class="vi">@device</span> <span class="o">=</span> <span class="no">Device</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="mi">987</span><span class="p">)</span>
<span class="vi">@user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="mi">246</span><span class="p">)</span>
<span class="vi">@user</span><span class="o">.</span><span class="n">async</span><span class="o">.</span><span class="n">activate</span><span class="p">(</span><span class="vi">@device</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
</pre></div>

<p>would be stored as:</p>

<div class="highlight"><pre><span class="p">{</span>
    <span class="s1">'class'</span><span class="o">:</span> <span class="s1">'User'</span><span class="p">,</span>
    <span class="s1">'args'</span><span class="o">:</span> <span class="p">[</span><span class="mi">246</span><span class="p">,</span> <span class="s1">'activate'</span><span class="p">,</span> <span class="mi">987</span><span class="p">]</span>
<span class="p">}</span>
</pre></div>

<p>Since all jobs are persisted in JSON, your jobs must only accept arguments that can be encoded into that format.
This is why our examples use object IDs instead of passing around objects.</p>

<h3>Processing Strategies</h3>

<p>In Backburner, there are actually multiple different strategies for processing jobs
which are reflected by multiple workers.
Custom workers can be <a href="https://github.com/nesquena/backburner/wiki/Defining-Workers">defined fairly easily</a>.
By default, Backburner comes with the following workers built-in:</p>

<table>
<tr>
<th>Worker</th>
<th>Description</th>
</tr>
<tr>
<td><code>Backburner::Workers::Simple</code></td>
<td>Single threaded, no forking worker. Simplest option.</td>
</tr>
</table><p>You can select the default worker for processing with:</p>

<div class="highlight"><pre><span class="no">Backburner</span><span class="o">.</span><span class="n">configure</span> <span class="k">do</span> <span class="o">|</span><span class="n">config</span><span class="o">|</span>
  <span class="n">config</span><span class="o">.</span><span class="n">default_worker</span> <span class="o">=</span> <span class="no">Backburner</span><span class="o">::</span><span class="no">Workers</span><span class="o">::</span><span class="no">Simple</span>
<span class="k">end</span>
</pre></div>

<p>or determine the worker on the fly when invoking <code>work</code>:</p>

<div class="highlight"><pre><span class="no">Backburner</span><span class="o">.</span><span class="n">work</span><span class="p">(</span><span class="s1">'newsletter_sender'</span><span class="p">,</span> <span class="ss">:worker</span> <span class="o">=&gt;</span> <span class="no">Backburner</span><span class="o">::</span><span class="no">Workers</span><span class="o">::</span><span class="no">Threaded</span><span class="p">)</span>
</pre></div>

<p>or when more official workers are supported, through alternate rake tasks.
Additional workers such as <code>threaded</code>, <code>forking</code> and <code>threads_on_fork</code> will hopefully be
developed in the future. If you are interested in helping, please let us know.</p>

<h3>Default Queues</h3>

<p>Workers can be easily restricted to processing only a specific set of queues as shown above. However, if you want a worker to
process <strong>all</strong> queues instead, then you can leave the queue list blank.</p>

<p>When you execute a worker without queues specified, any queue for a known job queue class with <code>include Backburner::Queue</code> will be processed.
To access the list of known queue classes, you can use:</p>

<div class="highlight"><pre><span class="no">Backburner</span><span class="o">::</span><span class="no">Worker</span><span class="o">.</span><span class="n">known_queue_classes</span>
<span class="c1"># =&gt; [NewsletterJob, SomeOtherJob]</span>
</pre></div>

<p>Dynamic queues created by passing queue options <strong>will not be processed</strong> by a default worker. For this reason, you may want to take control over the default list of
queues processed when none are specified. To do this, you can use the <code>default_queues</code> class method:</p>

<div class="highlight"><pre><span class="no">Backburner</span><span class="o">.</span><span class="n">default_queues</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="o">[</span><span class="s2">"foo"</span><span class="p">,</span> <span class="s2">"bar"</span><span class="o">]</span><span class="p">)</span>
</pre></div>

<p>This will ensure that the <em>foo</em> and <em>bar</em> queues are processed by default. You can also add job queue names:</p>

<div class="highlight"><pre><span class="no">Backburner</span><span class="o">.</span><span class="n">default_queues</span> <span class="o">&lt;&lt;</span> <span class="no">NewsletterJob</span><span class="o">.</span><span class="n">queue</span>
</pre></div>

<p>The <code>default_queues</code> stores the specific list of queues that should be processed by default by a worker.</p>

<h3>Failures</h3>

<p>When a job fails in backburner (usually because an exception was raised), the job will be released 
and retried again (with progressive delays in between) until the <code>max_job_retries</code> configuration is reached.</p>

<div class="highlight"><pre><span class="no">Backburner</span><span class="o">.</span><span class="n">configure</span> <span class="k">do</span> <span class="o">|</span><span class="n">config</span><span class="o">|</span>
  <span class="n">config</span><span class="o">.</span><span class="n">max_job_retries</span>  <span class="o">=</span> <span class="mi">3</span> <span class="c1"># retry jobs 3 times</span>
  <span class="n">config</span><span class="o">.</span><span class="n">retry_delay</span>      <span class="o">=</span> <span class="mi">2</span> <span class="c1"># wait 2 seconds in between retries</span>
<span class="k">end</span>
</pre></div>

<p>Note the default <code>max_job_retries</code> is 0, meaning that by default <strong>jobs are not retried</strong>.
If continued retry attempts fail, the job will be buried and can be 'kicked' later for inspection.</p>

<p>You can also setup a custom error handler for jobs using configure:</p>

<div class="highlight"><pre><span class="no">Backburner</span><span class="o">.</span><span class="n">configure</span> <span class="k">do</span> <span class="o">|</span><span class="n">config</span><span class="o">|</span>
  <span class="n">config</span><span class="o">.</span><span class="n">on_error</span> <span class="o">=</span> <span class="nb">lambda</span> <span class="p">{</span> <span class="o">|</span><span class="n">ex</span><span class="o">|</span> <span class="no">Airbrake</span><span class="o">.</span><span class="n">notify</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
</pre></div>

<p>Now all backburner queue errors will appear on airbrake for deeper inspection.</p>

<h3>Logging</h3>

<p>Logging in backburner is rather simple. When a job is run, the log records that. When a job
fails, the log records that. When any exceptions occur during processing, the log records that.</p>

<p>By default, the log will print to standard out. You can customize the log to output to any
standard logger by controlling the configuration option:</p>

<div class="highlight"><pre><span class="no">Backburner</span><span class="o">.</span><span class="n">configure</span> <span class="k">do</span> <span class="o">|</span><span class="n">config</span><span class="o">|</span>
  <span class="n">config</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="no">Logger</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="no">STDOUT</span><span class="p">)</span>
<span class="k">end</span>
</pre></div>

<p>Be sure to check logs whenever things do not seem to be processing.</p>

<h3>Hooks</h3>

<p>Backburner is highly extensible and can be tailored to your needs by using various hooks that
can be triggered across the job processing lifecycle. 
Often using hooks is much easier then trying to monkey patch the externals. </p>

<p>Check out <a href="https://github.com/nesquena/backburner/blob/master/HOOKS.md">HOOKS.md</a> for a detailed overview on using hooks.</p>

<h3>Workers in Production</h3>

<p>Once you have Backburner setup in your application, starting workers is really easy. Once <a href="http://kr.github.com/beanstalkd/download.html">beanstalkd</a>
is installed, your best bet is to use the built-in rake task that comes with Backburner. Simply add the task to your Rakefile:</p>

<div class="highlight"><pre><span class="c1"># Rakefile</span>
<span class="nb">require</span> <span class="s1">'backburner/tasks'</span>
</pre></div>

<p>and then you can start the rake task with:</p>

<div class="highlight"><pre><span class="nv">$ </span>rake backburner:work
<span class="nv">$ QUEUES</span><span class="o">=</span>newsletter-sender,push-message rake backburner:work
</pre></div>

<p>The best way to deploy these rake tasks is using a monitoring library. We suggest <a href="https://github.com/mojombo/god/">God</a>
which watches processes and ensures their stability. A simple God recipe for Backburner can be found in
<a href="https://github.com/nesquena/backburner/blob/master/examples/god.rb">examples/god</a>.</p>

<h3>Web Front-end</h3>

<p>Be sure to check out the Sinatra-powered project <a href="https://github.com/denniskuczynski/beanstalkd_view">beanstalkd_view</a>
by <a href="http://github.com/denniskuczynski">denniskuczynski</a> which provides an excellent overview of the tubes and
jobs processed by your beanstalk workers. An excellent addition to your Backburner setup.</p>

<h2>Acknowledgements</h2>

<ul>
<li>
<a href="https://github.com/nesquena">Nathan Esquenazi</a> - Project maintainer</li>
<li>Kristen Tucker - Coming up with the gem name</li>
<li>
<a href="https://github.com/timothy1ee">Tim Lee</a>, <a href="https://github.com/joshbuddy">Josh Hull</a>, <a href="https://github.com/Nico-Taing">Nico Taing</a> - Helping me work through the idea</li>
<li>
<a href="http://gomiso.com">Miso</a> - Open-source friendly place to work</li>
</ul><h2>Contributing</h2>

<ol>
<li>Fork it</li>
<li>Create your feature branch (<code>git checkout -b my-new-feature</code>)</li>
<li>Commit your changes (<code>git commit -am 'Added some feature'</code>)</li>
<li>Push to the branch (<code>git push origin my-new-feature</code>)</li>
<li>Create new Pull Request</li>
</ol><h2>References</h2>

<p>The code in this project has been made in light of a few excellent projects:</p>

<ul>
<li><a href="https://github.com/collectiveidea/delayed_job">DelayedJob</a></li>
<li><a href="https://github.com/defunkt/resque">Resque</a></li>
<li><a href="https://github.com/han/stalker">Stalker</a></li>
</ul><p>Thanks to these projects for inspiration and certain design and implementation decisions.</p>

<h2>Links</h2>

<ul>
<li>Code: <code>git clone git://github.com/nesquena/backburner.git</code>
</li>
<li>Home: <a href="http://github.com/nesquena/backburner">http://github.com/nesquena/backburner</a>
</li>
<li>Docs: <a href="http://rdoc.info/github/nesquena/backburner/master/frames">http://rdoc.info/github/nesquena/backburner/master/frames</a>
</li>
<li>Bugs: <a href="http://github.com/nesquena/backburner/issues">http://github.com/nesquena/backburner/issues</a>
</li>
<li>Gems: <a href="http://gemcutter.org/gems/backburner">http://gemcutter.org/gems/backburner</a>
</li>
</ul>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Backburner maintained by <a href="https://github.com/nesquena">nesquena</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
